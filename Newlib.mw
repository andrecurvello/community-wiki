= Introduction = 

The OpenRISC 1000 port of the newlib library aims to provide a library to provide support for running on bare-metal hardware without an operating system. It is also used when running the GNU toolchain regression suite.

The library is automatically linked when using the newlib version of the GCC compiler (or32-elf-gcc). The target board is specified by -m''boardname''. If not board is specified, the default (-mor1ksim) is suitable for use with [[Or1ksim]].

= Port acknowledgements =

This [http://www.doc.ic.ac.uk/~jab00/or32-newlib/ original port] was for newlib 1.13.0 by Jacob Bower, then of Imperial College, London.

The port was completely rewritten and tested for newlib 1.18.0 by [[User:Jeremybennett|Jeremy Bennett]] of [http://www.embecosm.com Embecosm].
Further information is availble in [http://www.embecosm.com/download/ean9.html Embecosm Application Note 9] ''Howto: Porting Newlib: A Simple Guide'', which explains in full detail how the port for the OpenRISC 1000 architecture was done.

The port was subsequently extended by [[User:Julius|Julius Baxter]] to make support of multiple boards much more flexible.

= OpenRISC support library =

To assist with using features of the OpenRISC processor such as exceptions, interrupts and timers, a support library has been implemented.

This library also provides support for particular boards in ORPSoC.

== Support library functions ==

These functions are implemented in the or1k-support.c and or1k-support-asm.S files in the <code>newlib/libc/machine/or32</code> path in the newlib port directory. The header, <code>or1k-newlib-support.h</code> is found in the <code>newlib/libc/machine/or32/include</code> path. Note that this header and the OR1K <code>spr-defs.h</code> header are installed also in the <code>/install_path/or32-elf/include</code> path.

They are accessible via the inclusion of the following header.

 <code>#include <or1k-newlib-support.h></code>

The following functions are provided

{| border="1" align="center" style="text-align:center;"
|'''Function Name'''
|'''Arguments'''
|'''Description'''
|'''Return value'''
|-
|<code>or1k_interrupt_handler_add</code>
|<code>int irq, void(*function_name)(void*)</code>
|Install function_name as handler for interrupt at IRQ <code>irq</code>
|none
|-
|<code>or1k_interrupt_enable</code>	
|<code>int irq</code>	
|Enable generation interrupt at IRQ irq in PICMR	
|none
|-
|<code>or1k_interrupt_disable</code>	
|<code>int irq</code>	
|Disable generation of interrupt at IRQ irq in PICMR	
|none
|-
|<code>or1k_exception_handler_add</code>	
|<code>int vector, void(*function_name)(void*)</code>	
|Install function_name as handler for vector at address (vector*0x100)	
|none
|-
|<code>or1k_mtspr</code>	
|<code>unsigned long int spr, unsigned long int value</code>	
|Write SPR[spr] = value	
|none
|-
|<code>or1k_mfspr</code>	
|<code>unsigned long int spr</code>	
|Read SPR[spr]	
|SPR[spr]
|-
|<code>or1k_report</code>	
|<code>unsigned long int value</code>	
|Simulator report function with l.nop 0x2	
|none
|-
|<code>or1k_icache_enable</code>	
|<code>void</code>	
|Enable instruction cache in SR	
|none
|-
|<code>or1k_icache_disable</code>	
|<code>void</code>	
|Disable instruction cache in SR	
|none
|-
|<code>or1k_icache_flush</code>	
|<code>unsigned long addr</code>	
|Flush addr from instruction cache	
|none
|-
|<code>or1k_dcache_enable</code>	
|<code>void</code>	
|Enable data cache in SR	
|none
|-
|<code>or1k_dcache_disable</code>	
|<code>void</code>	
|Disable data cache in SR	
|none
|-
|<code>or1k_dcache_flush</code>	
|<code>unsigned long addr</code>	
|Flush addr from data cache	
|none
|-
|<code>or1k_immu_enable</code>	
|<code>void</code>	
|Enable instruction MMU in SR	
|none
|-
|<code>or1k_immu_disable</code>	
|<code>void</code>	
|Disable instruction MMU in SR	
|none
|-
|<code>or1k_dmmu_enable</code>	
|<code>void</code>	
|Enable data MMU in SR	
|none
|-
|<code>or1k_dmmu_disable</code>	
|<code>void</code>	
|Disable data MMU in SR	
|none
|-
|<code>or1k_timer_init</code>	
|<code>unsigned int hz</code>	
|Initialise timer to count at hz hertz, reset tick counter, install handler	
|none
|-
|<code>or1k_timer_enable</code>	
|<code>void</code>	
|Start timer, enable timer interrupt in SR	
|none
|-
|<code>or1k_timer_disable</code>	
|<code>void</code>	
|Stop timer interrupts	
|none
|-
|<code>or1k_timer_get_ticks</code>	
|<code>void</code>	
|Read tick counter value	
|tick counter
|-
|<code>or1k_timer_reset_ticks</code>	
|<code>void</code>	
|Reset tick counter value	
|none
|}

Contributions are welcome to help fix and improve this support library.

Feel free to post any suggestions or offers to assist the project to the OpenRISC forum or [openrisc_team@opencores.org]

=== TODO ===

Functions still missing: interrupt acknowledge/clear function to clear bit in PICSR, cache region flush, MMU map function.

== Board support details ==

Libgloss now provides an easy way of adding additional boards by way of linking in a small library containing just a few values used at run-time to configure the system. Each board has its own path and libboard.a in the /install_path/or32-elf/lib/boards directory. The boardname above should correspond to a directory under this path.

Libgloss also implements system calls, and at present only basic I/O via UART is implemented for the read and write system calls.

In toolchain version 1.0rc1 a handful of boards and the or1ksim architectural simulator are supported.

TODO - further details
