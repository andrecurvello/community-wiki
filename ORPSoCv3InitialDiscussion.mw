Why ORPSoCv3? Because [[User:julius|Julius]] would hate the name ;)

ORPSoC is the reference platform for OpenRISC development. It has many users and can be extended to lots of FPGA boards. There are however many users that prefer minSOC as it is considered to be easier to get started with.

Here's a proposal for improving things in ORPSoC land

== Create a separate project ==

ORPSoC pulls together lots of different OpenCores projects. It should be a separate project in its own right, like [[OR1K:MinSoC]], not part of OpenRISC (which should just be about the processor). [[User:Jeremybennett|Jeremybennett]] 19:13, 18 August 2011 (CEST)
*Agreed. I was initially tasked with developing ORPSoC(v2.0) mainly as a testbench for the OR1200, however the board build thing grew out of it, and now I think it's got enough momentum and interest for it to be deemed worthy for its own project. [[User:Julius|Julius]] 00:09, 25 August 2011 (CEST)
* There is now an '''experimental''' ORPSoCv3 repo on git.opencores.org. This will not replace ORPSoCv2 for some time, but can serve as a playground for the infrastructure. I have also created a separate [http://opencores.org/project,orpsoc ORPSoC project] to increase the visibility of ORPSoCv2. Currently it will only point to the existing ORPSoCv2 information [[User:Olof|Olof]] 14:06, 31 August 2011 (CEST)
There is a case for pulling the tool chains and operating systems out into separate projects to make the whole thing more manageable. [[User:Jeremybennett|Jeremybennett]] 11:02, 23 August 2011 (CEST)
* This isn't really an issue for ORPSoC, but I think this makes sense. [[User:Julius|Julius]] 00:10, 25 August 2011 (CEST)


We do want to split this into as many different projects as possible. Do not embed the or1200 (or any other) component into this project. We download that from the repository along with all the rest. We are trying to do three separate things here and everybody is getting them mixed up.
We are creating a component called orpsocv3 and putting it in a project that is also called orpsocv3. On top of that it also serves as the design
environment where all the scripts are run. The project that we are calling orpsocv3 is not a component. It is a library that contains the orpsocv3 component. It also contains application software which we must treat like is a different type of component. We should call the library project or1k_socs so then we can put in orpsocv2 as well. We could even put the minsoc component in as well and build it in this design environment. The design environment that we are building could be reused by any opencores project. That should go into its own separate project. If you want to build something do this:

* check out the design environment project. Run a script that installs any system tools and configures your system

* run a download script for or1k_socs:oprsocv3. It will download this component as well as all other modules needed to build it

* run make all. this will build the code and run all the tools

Don't put anything in here that is usable by other projects. Put them in a separate project [[User:jt_eaton|jt_eaton]] 18:25, 3 September 2011 (CEST)

== Modules ==
* Use the <code>modules</code> directory for external cores. These could be managed with svn externals, git submodules, or symlinks if it's not desirable to just dump the cores there. [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** This is a good approach, resulting in not having multiple copies of a core sitting around in various repositories which can be confusing and difficult to manage. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** The problem of managing the source of an IP which requires modification to work with a board build in ORPSoC should be solved external to the ORPSoC project. It should be acceptable that modules can be pulled in (via a scripted system) from arbitrary repositories, not necessarily along side where ORPSoC is hosted. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
**** Examples of modifications that a core might require are the addition of a Makefile supporting the rules outlined below, renaming of top-level modules and their ports to comply with the standard naming styles used in ORPSoC, addition of technology-specific support to assist synthesis, replacement of `defines with parameters to enable multiple instances which differ. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** This also allows different versions of a core to be used as required in different board builds. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
**** ORPSoC-specific changes to cores could be kept as patches in ORPSoC, that are applied by the Makefile when each module/core is downloaded. [[User:Olof|Olof]] 20:01, 28 August 2011 (CEST)
***** Those patches could be handled by git which would have the benefits: 1) The patches are automatically numbered 2) Commit messages are included in the patches 3) It makes it easy to 'hack' on the local core and keep track of changes. --[[User:Stekern|Stekern]] 04:42, 2 September 2011 (CEST)
* Add a top level Makefile that contains the following rules [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** list-rtl-files : Returns a list of the modules' and it's submodules' rtl-files. Used in top level Makefile to create project files for synthesis and simulation. I made a [http://dl.dropbox.com/u/902237/recmake.tar.gz proof-of-concept sketch] of how something like this could work [[User:Olof|Olof]] 23:07, 24 August 2011 (CEST)
*** The Makefile should run the actual synthesis and simulations tools as well. Or better call other makefiles associated with synthesis, simulation, linter, FV, tools. This allows for easy maintenance and extension of the supported tools. [[User:Rherveille|Rherveille]] 12:10, 24 August 2011 (CEST)
**** Agreed. Please add any Makefile rules that makes sense to have. Most rules would probably make sense to have recursive, so that they can be run on a stand-alone module as well as a module being part of ORPSoC [[User:Olof|Olof]] 20:01, 28 August 2011 (CEST)
** list-include-dirs : Returns a list of the modules' and it's submodules' directories containing include files. Used in top level Makefile to create project files for synthesis and simulation
** get-modules : Download the required submodules to the modules dir. Not sure how this should be done. Requires knowledge of each submodules' repo or download location, but this could maybe be solved with a simple ebuild-like systems. I guess the three main cases are SVN, GIT and tar balls [[User:Olof|Olof]] 23:07, 24 August 2011 (CEST)

== Configuration ==
Kbuild has been proposed here. Pros/cons?

I would like to have a standardized set of makefiles for every ORPSoC build, and include a Makefile.inc that contains all user parameters. I've been discussing with Saar Drimer at [https://www.boldport.com/docs/fpgaproj boldport] about integrating his work with our efforts [[User:Olof|Olof]] 09:48, 19 August 2011 (CEST)

I took a quick look at boldport. It isn't rocketscience they are doing; anyone working with multiple tools uses the same approach. What I don't like about it, is that it is not generic enough. It is too FPGA centric.--[[User:Rherveille|Rherveille]] 18:29, 24 August 2011 (CEST)

For hardware configuration we should aim to replace defines and defparams with parameters [[User:Olof|Olof]] 21:00, 19 August 2011 (CEST)

Yes definitely; parameters only. Defines can be used for special cases, but none should be used in the actual RTL files.--[[User:Rherveille|Rherveille]] 18:29, 24 August 2011 (CEST)

== Software integration ==
People might want to build software running on their ORPSoC. Is this feasible?
* Definitely - we might want to integrate more with newlib - it was my ambition move all of the software to be based on newlib, rather than the little bare metal libraries I've put together in ORPSoC. I think this should be pursued for the next iteration of this project. [[User:Julius|Julius]] 00:13, 25 August 2011 (CEST)

== Name and version ==
Actually, ORPSoCv3 makes sense, but I'd prefer to see it called just ORPSoC and have version numbers (my flavor of the month) for the project when we tag it beginning at 3.0.0. We could then refer to the previous versions as 1 (the original, long gone) and 2 (the one being worked on at the moment, expect to see this in use until 3.0 gets up.)  [[User:Julius|Julius]] 14:17, 20 August 2011 (CEST)
: I agree. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Hardware ==
All critical features requests and bugs in ORPSoCv2 should be addressed before adding features (and more bugs) in ORPSoCv3.
* Fair enough. [http://bugzilla.opencores.org/show_bug.cgi?id=59 These] [http://bugzilla.opencores.org/show_bug.cgi?id=56 two] was what I could find in Bugzilla. We might need to scrape the old and new bug system to see if there are more [[User:Olof|Olof]] 23:24, 22 August 2011 (CEST)
:: I scraped the old bug tracker and put anything even vaguely still alive in Bugzilla. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Project structure ==
The current ORPSoC structure follows the recommended OpenCores structures, but has grown out of it because of the board ports and multiple modules. 
For ORPSoCv3, it would be preferred to side-step the OpenCores structure where it makes sense for ORPSoC itself, while benefiting from the fact that most cores have a similar structure.
: The following issues has been identified with the ORPSoCv2 structure and should be rectified in ORPSoCv3
* Too many levels of hierarchy
* Temporary build files spread out through the project tree
* Common workflow requires changing directories often

The proposed structure addresses this by assigning a common build-directory, moving Makefiles to the top-level and flattens out some of the directory trees [[User:Olof|Olof]] 19:49, 30 August 2011 (CEST)


Either your formatting is munged or the rtl code is under the doc directory.  I would like to see where all the different variants will store their results. For example if you have 3 different software apps then you will need three different simulations and bitfiles. If you can configure the 
or1200 for I-cache,dcache and debugger then you could be dealing with up to 24 combinations. The full test suite has to be able to run all supported configurations and save the results [[User:jt_eaton]] 30 August 2011
* Formatting is corrected. Haven't thought of the issue with several results. One idea might be to send a parameter to the Makefile that assigns a namespace or subdirectory for the different simulation results/bitfiles. Any other ideas? [[User:Olof|Olof]] 22:25, 1 September 2011 (CEST)

Simulation suites can be very easy to parallelize and farm out to multiple cores as long as you don't do anything that prevents 2 sims from running at the same time. If all your sims run in the same directory and you have any filename that is shared then you will have problems. I create a separate subdirectory for each sim to completely isolate them from each other. This directory contains the test sequence initial statement that directs all the reads/writes and testing. There is also a dumpfile fragment and a gtkwave .sav file. That way each sim can control its dump file and how it is displayed. I have other system files that control the testbench creation and configuration for each sim [[User:jt_eaton|jt_eaton]] 1:19 2 September 2011 (CEST) 

* '''orpsoc'''
**bench
***sysc
***verilog
**boards
***actel-ordb1a3pe1500
***altera-de0_nano
***xilinx-atlys
***xilinx-ml501
****data
*****constraints.ucf
*****coregen
****rtl
*****verilog
******clk_gen
******mem_ctrl
****orpsoc_top.v
**build
***ise
***modelsim
***ncsim
***synplify
***xst
**cores
***ac97
***ethmac
***or1200
***spi
***usb
**doc
**rtl
***verilog
****arbiter
****bootrom
**scripts
**sim
***isim
***modelsim
***ncsim
**sw
***apps
***tests
***utils
**Makefile

=== Alternate set up ===
[[User:Julius|Julius]] 23:06, 1 September 2011 (CEST)

I think we should make all modules drop into each board build and not be available "globally" across ORPSoC.

This is probably a discussion for elsewhere, but I think the testbench and maybe model files for each core should be housed with each module in each build. I would prefer to see the core that we're pulling in provide the testbench modules and models to test against.

As much as possible, scripts should be kept globally.

A set of common models (eg. memory) and utility cores/functions (eg. UART decoders) for testbenches and the like should be provided. If any design module becomes so common that every build is using it, it could live in the common/rtl path.


If any design module is usable for any other projects then it should not be inside of orpsoc, it should be in its own library project. We know that every wishbone peripheral will need a wishbone master BFM. So create a opencores project for testbench modules and put it there. Putting a copy of or1200 inside of orpsoc was a bad idea because nobody knew which one is the true source. The same is true for all modules. You need a module that everyone else needs? Put it in the versatile_library project and let everyone use that as a source. Don't make copies. [[User:jt_eaton|jt_eaton]] 05:23, 2 September 2011 (CEST)


==== Software - still unsure ====
I would be happy to have a sw/ path at the base of the project if there was an easy way to allow each build to customise the libraries to its needs (which drivers to build and link essentially), like we do now in ORPSoC.
Ideally I would prefer to see a move to a model where the core/module we pull in provides bare-metal drivers that the processor can use. Perhaps common test functions for a "service" (spi,uart,i2c,ethernet,memory) live in the root sw/ and contain calls to the drivers and functions provided by the core.

Agreed. A transactor and a bare-metal driver would be great to have for each core. It could be worth a try to have these as patches to begin with. Basic infrastructure for patching of pulled-in cores is already implemented [[User:Olof|Olof]] 14:13, 2 September 2011 (CEST)

==== Testing and development facilities ====
Sorry to dump all of my ideas in this space, but I think what would be ''really'' cool is to have two types of testing capabilities. One where the processor simply triggers a bit of behavioural verilog in the testbench which then tests a core in the usual "standalone" testbench fashion, and one where the processor is largely doing the testing of the core from the CPU side. A mixture of both could also be achieved. But basically, the first type, where the core triggers some behavioural block to do its thing would be very handy to have, and to be able to manage the source of. Basically I would like to get to a position where the ''proper'' development of a block can occur in a build in ORPSoC and then allow you to transition into the control of the block by the CPU. That core, however, would still be testable by taking the testbench and triggering the 'go' condition of the test by some other means.

Absolutely. ORPSoC should assist in the development process of a new core. Having behavioural models of the surrounding blocks is how things should be done. Now we just have to find someone to write them. Just having a proper wishbone transactor would get us far. [[User:Olof|Olof]] 14:13, 2 September 2011 (CEST)
==== Structure ====

So, something like:

'''orpsoc'''
* builds
** generic-or1200-reference
** generic-or1200-fancyfeaturedemo
** generic-otheror1k-reference
** xilinx-ml501
** xilinx-atlys
** actel-ordb1a3pe1500
** '''technology'''-'''buildnamename'''
*** '''Makefile''' ''- a main build makefile for pulling in modules and setting up anything else required''
*** modules
*** simulation
**** run
**** scripts
***** ''just some simple scripts, mainly pulling in other fragments''
*** synthesis
**** run
**** scripts
* common
** models
*** verilog
*** vhdl
*** systemc
** bench
*** verilog
*** vhdl
*** systemc
** rtl ''(possibly)''
* scripts
** make
** bash
** perl

Comments on [[User:Julius|Julius]]' alternative structure [[User:Olof|Olof]] 14:13, 2 September 2011 (CEST)
* builds/vendor-cpu-some-other-string : I believe that most of the time, you would build ORPSoC for only one board, and definitely with or1200 as the target CPU. Therefore, I feel it only makes things more complex and adds another hierarchy level to have a naming scheme for the builds. I would prefer that we just have syn, par and sim (and probably a few more) directories in the build path. If a user wants to put the files somewhere else, this can be overridden with a Makefile variable, e.g, <tt>make netlist BUILD_DIR=generic-or1200-fancyfeature-demo</tt>
* The case for making cores available globally is that many cores such as spi, ethmac, or1200 (I see or1200 as just another core, although it has some special attributes) and uart are used by both the generic ORPSoC environment and most of the board builds. Having separate copies in the tree doesn't make sense

== Use an IP-Xact enabled tool flow ==

Orpsocv3 would be a great opportunity for opencores to stop playing catch up
and start showing a leadership roll in ip packaging and reuse by building a
complete soc design using an Ip-Xact enabled tool flow.

Ip-xact (IEEE 1685) was released in 2009 and has the potential to solve many of
our design for reuse problems but its adoption by the industry has been slow.
A big part of the problem is that a standard should simply document what everyone
is already doing but in the case of design for reuse there really aren't a lot
of examples of good working design for reuse methods. Accellera is currently working
on a update to the standard that would add in some of the vendor extensions that
tool providers have needed to make the standard workable. This is a time when we could
use orpsocv3 as a demo project for ip-xact and feedback any problems or issues back to
the ip-xact working group. I follow that groups monthly teleconferences.


Ip-xact defines an electronic data sheet in the form of an xml file that describes a
piece of ip. Every file contains an identifier known as a VLNV. That consists of the
vendor name (in our case it opencores.org) , library name. component name and version.
  
The file also lists all parameters with default values, All ports with sizes and directions
and all design "views". A view is a improvement over the traditional way that we have done
designs. We currently do "superset" designs where we create one delivierable that is sent
to all tool flows. Anything that any tool needs is added to the design and if this causes
problems for other tools (IE: Non synthesizable code) then we use translate off pragmas
or `ifndef SYNTHESIS to hide it from the other tools.

With ip-xact you create a view for each of your tool flows and each view builds its own 
deliverable with exactly what it needs and nothing more. The ip-xact file will define
a views for sim and syn and each will have their own output file.


To get started we need to understand the difference between a library and a component. 
A component is building block that we will configure and add into our design. Every component
must have an ip-xact file, Rtl code , Documentation and a test suite.

A library is a box that holds components. Usually there is a common theme that all the components
share. Or1200, minsoc and orpsocv2 are all components. openrisc is a library because it contains
several components.

opencores.org is currently using a flat database full of components mixed in with libraries.
We should add some more libraries to help us better manage all the ip. For example we should
create a library named wishbone that would either contain wishbone components or svn remote
mount them. That will give us the library name for the ip-xact files.

Also you should never create a wishbone component. If you want an i2c_controller on a wishbone
bus then you first create and i2c_controller in a logic library and then create a wishbone 
component that uses ip-xact to instantiate that i2c_controller. That way any bus de jour could
easily reuse the same i2c logic.

Currently I am building an ip-xact toolset in the socgen project that could be used to build 
all of the rtl code for a soc such as opsocv3. I recently added the ability to support busDefinitions
(really powerfull stuff) and soon will begin to add support for memory maps. With memory maps each 
ip-xact file contains a register map with all the bitfields. If you add two wishbone i2c_controllers
into oprsocv3 and rerun the build_hw script then they will appear in the .h file.

I would be happy to create and maintain all of the ip-xact files needed to build orpsocv3 and set up
the design so that you could build the rtl using the socgen toolset.

John Eaton

: John - it's a good idea, but there is (I believe) a dearth of open source IP-XACT tooling. In fact there is a shortage of good IP-XACT tooling all round as far as I can see. The only half-decent stuff was from Beach who went bust a couple of years ago. So we'll need another project to write some open source IP-XACT tools. If only there were more hours in the day.
: Another thing is that IP-XACT only gives part of the solution. It helps you define the interfaces (you'll need the latest version to define temporal aspects). However it doesn't define internal state or function of IP blocks, which are the two other things you required.
: Finally. I'm not sure what the legal position would be around using IP-XACT in an open source context. The SPIRIT consortium (which owns IP-XACT) is a membership body, with some fairly demanding requirements on members. [[User:Jeremybennett|Jeremybennett]] 11:01, 23 August 2011 (CEST)

: IP-XACT sounds like a great initiative, but if what Jeremy says is true, then it seems we would have some trouble implementing support. I think we should concentrate on structuring all our modules instead, so that when or if we are ready to join IP-XACT, there will at least be less ad-hoc structures. This includes bundling up things in libraries and general code cleanup. We might even be interested in inserting parts of the XML description in some cores [[User:Olof|Olof]] 23:25, 24 August 2011 (CEST)

: The spirit consortium no longer exists. They have merged with accellera and that  body now supports the standard. It is a IEEE standard (1685-2009) and the accellera website links to a free downloadable copy. They are trying to jump start its usage within the industry. There certainly is a dearth of open source IP-XACT software. That is one of my goals for the socgen project is to create a set of scripts that can use the IP-XACT descriptors to build the rtl code and other deliverables. I would like to use oprsocv3 for a pilot run to test these scripts in a complex design environment . This would mean adding a IP-XACT file to every ip component and running a build script to generate the final rtl. For a project like this one we could also have all the generated rtl checked into the repository so that anybody who didn't  want to run the build_hw script could use the preexisting copy but you could also regenerate the same files from the ip-xact files as well. My philosophy is that design for reuse follows the 80/20 rule. You can do 20% of a design for reuse effort and that will give you 80% of the benefit. If you are a commercial IP house then you still have to put forth the remaining 80% before you can sell the product but this group doesn't have to go that far. Opencores does have guidelines for having a build hardware process that runs all the code through a verilog preprocessor. That is included in mysocgen tool set. I could add that as a process step for any opencores project.   John Eaton

: Jeremy, Beach sold all their assets to Duolog over in Dublin. Their products are still around. John Eaton
