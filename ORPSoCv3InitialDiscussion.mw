Why ORPSoCv3? Because [[User:julius|Julius]] would hate the name ;)

ORPSoC is the reference platform for OpenRISC development. It has many users and can be extended to lots of FPGA boards. There are however many users that prefer minSOC as it is considered to be easier to get started with.

Here's a proposal for improving things in ORPSoC land

== Create a separate project ==

ORPSoC pulls together lots of different OpenCores projects. It should be a separate project in its own right, like [[OR1K:MinSoC]], not part of OpenRISC (which should just be about the processor). [[User:Jeremybennett|Jeremybennett]] 19:13, 18 August 2011 (CEST)
*Agreed. I was initially tasked with developing ORPSoC(v2.0) mainly as a testbench for the OR1200, however the board build thing grew out of it, and now I think it's got enough momentum and interest for it to be deemed worthy for its own project. [[User:Julius|Julius]] 00:09, 25 August 2011 (CEST)

There is a case for pulling the tool chains and operating systems out into separate projects to make the whole thing more manageable. [[User:Jeremybennett|Jeremybennett]] 11:02, 23 August 2011 (CEST)
* This isn't really an issue for ORPSoC, but I think this makes sense. [[User:Julius|Julius]] 00:10, 25 August 2011 (CEST)

== Modules ==
* Use the <code>modules</code> directory for external cores. These could be managed with svn externals, git submodules, or symlinks if it's not desirable to just dump the cores there. [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** This is a good approach, resulting in not having multiple copies of a core sitting around in various repositories which can be confusing and difficult to manage. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** The problem of managing the source of an IP which requires modification to work with a board build in ORPSoC should be solved external to the ORPSoC project. It should be acceptable that modules can be pulled in (via a scripted system) from arbitrary repositories, not necessarily along side where ORPSoC is hosted. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
**** Examples of modifications that a core might require are the addition of a Makefile supporting the rules outlined below, renaming of top-level modules and their ports to comply with the standard naming styles used in ORPSoC, addition of technology-specific support to assist synthesis, replacement of `defines with parameters to enable multiple instances which differ. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** This also allows different versions of a core to be used as required in different board builds. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
**** ORPSoC-specific changes to cores could be kept as patches in ORPSoC, that are applied by the Makefile when each module/core is downloaded. [[User:Olof|Olof]] 20:01, 28 August 2011 (CEST)
* Add a top level Makefile that contains the following rules [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** list-rtl-files : Returns a list of the modules' and it's submodules' rtl-files. Used in top level Makefile to create project files for synthesis and simulation. I made a [http://dl.dropbox.com/u/902237/recmake.tar.gz proof-of-concept sketch] of how something like this could work [[User:Olof|Olof]] 23:07, 24 August 2011 (CEST)
*** The Makefile should run the actual synthesis and simulations tools as well. Or better call other makefiles associated with synthesis, simulation, linter, FV, tools. This allows for easy maintenance and extension of the supported tools. [[User:Rherveille|Rherveille]] 12:10, 24 August 2011 (CEST)
**** Agreed. Please add any Makefile rules that makes sense to have. Most rules would probably make sense to have recursive, so that they can be run on a stand-alone module as well as a module being part of ORPSoC [[User:Olof|Olof]] 20:01, 28 August 2011 (CEST)
** list-include-dirs : Returns a list of the modules' and it's submodules' directories containing include files. Used in top level Makefile to create project files for synthesis and simulation
** get-modules : Download the required submodules to the modules dir. Not sure how this should be done. Requires knowledge of each submodules' repo or download location, but this could maybe be solved with a simple ebuild-like systems. I guess the three main cases are SVN, GIT and tar balls [[User:Olof|Olof]] 23:07, 24 August 2011 (CEST)

== Configuration ==
Kbuild has been proposed here. Pros/cons?

I would like to have a standardized set of makefiles for every ORPSoC build, and include a Makefile.inc that contains all user parameters. I've been discussing with Saar Drimer at [https://www.boldport.com/docs/fpgaproj boldport] about integrating his work with our efforts [[User:Olof|Olof]] 09:48, 19 August 2011 (CEST)

I took a quick look at boldport. It isn't rocketscience they are doing; anyone working with multiple tools uses the same approach. What I don't like about it, is that it is not generic enough. It is too FPGA centric.--[[User:Rherveille|Rherveille]] 18:29, 24 August 2011 (CEST)

For hardware configuration we should aim to replace defines and defparams with parameters [[User:Olof|Olof]] 21:00, 19 August 2011 (CEST)

Yes definitely; parameters only. Defines can be used for special cases, but none should be used in the actual RTL files.--[[User:Rherveille|Rherveille]] 18:29, 24 August 2011 (CEST)

== Software integration ==
People might want to build software running on their ORPSoC. Is this feasible?
* Definitely - we might want to integrate more with newlib - it was my ambition move all of the software to be based on newlib, rather than the little bare metal libraries I've put together in ORPSoC. I think this should be pursued for the next iteration of this project. [[User:Julius|Julius]] 00:13, 25 August 2011 (CEST)

== Name and version ==
Actually, ORPSoCv3 makes sense, but I'd prefer to see it called just ORPSoC and have version numbers (my flavor of the month) for the project when we tag it beginning at 3.0.0. We could then refer to the previous versions as 1 (the original, long gone) and 2 (the one being worked on at the moment, expect to see this in use until 3.0 gets up.)  [[User:Julius|Julius]] 14:17, 20 August 2011 (CEST)
: I agree. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Hardware ==
All critical features requests and bugs in ORPSoCv2 should be addressed before adding features (and more bugs) in ORPSoCv3.
* Fair enough. [http://bugzilla.opencores.org/show_bug.cgi?id=59 These] [http://bugzilla.opencores.org/show_bug.cgi?id=56 two] was what I could find in Bugzilla. We might need to scrape the old and new bug system to see if there are more [[User:Olof|Olof]] 23:24, 22 August 2011 (CEST)
:: I scraped the old bug tracker and put anything even vaguely still alive in Bugzilla. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Use an IP-Xact enabled tool flow ==

Orpsocv3 would be a great opportunity for opencores to stop playing catch up
and start showing a leadership roll in ip packaging and reuse by building a
complete soc design using an Ip-Xact enabled tool flow.

Ip-xact (IEEE 1685) was released in 2009 and has the potential to solve many of
our design for reuse problems but its adoption by the industry has been slow.
A big part of the problem is that a standard should simply document what everyone
is already doing but in the case of design for reuse there really aren't a lot
of examples of good working design for reuse methods. Accellera is currently working
on a update to the standard that would add in some of the vendor extensions that
tool providers have needed to make the standard workable. This is a time when we could
use orpsocv3 as a demo project for ip-xact and feedback any problems or issues back to
the ip-xact working group. I follow that groups monthly teleconferences.


Ip-xact defines an electronic data sheet in the form of an xml file that describes a
piece of ip. Every file contains an identifier known as a VLNV. That consists of the
vendor name (in our case it opencores.org) , library name. component name and version.
  
The file also lists all parameters with default values, All ports with sizes and directions
and all design "views". A view is a improvement over the traditional way that we have done
designs. We currently do "superset" designs where we create one delivierable that is sent
to all tool flows. Anything that any tool needs is added to the design and if this causes
problems for other tools (IE: Non synthesizable code) then we use translate off pragmas
or `ifndef SYNTHESIS to hide it from the other tools.

With ip-xact you create a view for each of your tool flows and each view builds its own 
deliverable with exactly what it needs and nothing more. The ip-xact file will define
a views for sim and syn and each will have their own output file.


To get started we need to understand the difference between a library and a component. 
A component is building block that we will configure and add into our design. Every component
must have an ip-xact file, Rtl code , Documentation and a test suite.

A library is a box that holds components. Usually there is a common theme that all the components
share. Or1200, minsoc and orpsocv2 are all components. openrisc is a library because it contains
several components.

opencores.org is currently using a flat database full of components mixed in with libraries.
We should add some more libraries to help us better manage all the ip. For example we should
create a library named wishbone that would either contain wishbone components or svn remote
mount them. That will give us the library name for the ip-xact files.

Also you should never create a wishbone component. If you want an i2c_controller on a wishbone
bus then you first create and i2c_controller in a logic library and then create a wishbone 
component that uses ip-xact to instantiate that i2c_controller. That way any bus de jour could
easily reuse the same i2c logic.

Currently I am building an ip-xact toolset in the socgen project that could be used to build 
all of the rtl code for a soc such as opsocv3. I recently added the ability to support busDefinitions
(really powerfull stuff) and soon will begin to add support for memory maps. With memory maps each 
ip-xact file contains a register map with all the bitfields. If you add two wishbone i2c_controllers
into oprsocv3 and rerun the build_hw script then they will appear in the .h file.

I would be happy to create and maintain all of the ip-xact files needed to build orpsocv3 and set up
the design so that you could build the rtl using the socgen toolset.

John Eaton

: John - it's a good idea, but there is (I believe) a dearth of open source IP-XACT tooling. In fact there is a shortage of good IP-XACT tooling all round as far as I can see. The only half-decent stuff was from Beach who went bust a couple of years ago. So we'll need another project to write some open source IP-XACT tools. If only there were more hours in the day.
: Another thing is that IP-XACT only gives part of the solution. It helps you define the interfaces (you'll need the latest version to define temporal aspects). However it doesn't define internal state or function of IP blocks, which are the two other things you required.
: Finally. I'm not sure what the legal position would be around using IP-XACT in an open source context. The SPIRIT consortium (which owns IP-XACT) is a membership body, with some fairly demanding requirements on members. [[User:Jeremybennett|Jeremybennett]] 11:01, 23 August 2011 (CEST)

: IP-XACT sounds like a great initiative, but if what Jeremy says is true, then it seems we would have some trouble implementing support. I think we should concentrate on structuring all our modules instead, so that when or if we are ready to join IP-XACT, there will at least be less ad-hoc structures. This includes bundling up things in libraries and general code cleanup. We might even be interested in inserting parts of the XML description in some cores [[User:Olof|Olof]] 23:25, 24 August 2011 (CEST)

: The spirit consortium no longer exists. They have merged with accellera and that  body now supports the standard. It is a IEEE standard (1685-2009) and the accellera website links to a free downloadable copy. They are trying to jump start its usage within the industry. There certainly is a dearth of open source IP-XACT software. That is one of my goals for the socgen project is to create a set of scripts that can use the IP-XACT descriptors to build the rtl code and other deliverables. I would like to use oprsocv3 for a pilot run to test these scripts in a complex design environment . This would mean adding a IP-XACT file to every ip component and running a build script to generate the final rtl. For a project like this one we could also have all the generated rtl checked into the repository so that anybody who didn't  want to run the build_hw script could use the preexisting copy but you could also regenerate the same files from the ip-xact files as well. My philosophy is that design for reuse follows the 80/20 rule. You can do 20% of a design for reuse effort and that will give you 80% of the benefit. If you are a commercial IP house then you still have to put forth the remaining 80% before you can sell the product but this group doesn't have to go that far. Opencores does have guidelines for having a build hardware process that runs all the code through a verilog preprocessor. That is included in mysocgen tool set. I could add that as a process step for any opencores project.   John Eaton

: Jeremy, Beach sold all their assets to Duolog over in Dublin. Their products are still around. John Eaton
