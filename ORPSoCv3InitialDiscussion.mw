Why ORPSoCv3? Because [[User:julius|Julius]] would hate the name ;)

ORPSoC is the reference platform for OpenRISC development. It has many users and can be extended to lots of FPGA boards. There are however many users that prefer minSOC as it is considered to be easier to get started with.

Here's a proposal for improving things in ORPSoC land

== Create a separate project ==

ORPSoC pulls together lots of different OpenCores projects. It should be a separate project in its own right, like [[OR1K:MinSoC]], not part of OpenRISC (which should just be about the processor). [[User:Jeremybennett|Jeremybennett]] 19:13, 18 August 2011 (CEST)

== Modules ==
* Use the <code>modules</code> directory for external cores. These could be managed with svn externals, git submodules, or symlinks if it's not desirable to just dump the cores there. [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** This is a good approach, resulting in not having multiple copies of a core sitting around in various repositories which can be confusing and difficult to manage. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** The problem of managing the source of an IP which requires modification to work with a board build in ORPSoC should be solved external to the ORPSoC project. It should be acceptable that modules can be pulled in (via a scripted system) from arbitrary repositories, not necessarily along side where ORPSoC is hosted. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
**** Examples of modifications that a core might require are the addition of a Makefile supporting the rules outlined below, renaming of top-level modules and their ports to comply with the standard naming styles used in ORPSoC, addition of technology-specific support to assist synthesis, replacement of `defines with parameters to enable multiple instances which differ. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
*** This also allows different versions of a core to be used as required in different board builds. [[User:Julius|Julius]] 14:45, 20 August 2011 (CEST)
* Add a top level Makefile that contains the following rules [[User:Olof|Olof]] 19:19, 18 August 2011 (CEST)
** list-rtl-files : Returns a list of the modules' and it's submodules' rtl-files. Used in top level Makefile to create project files for synthesis and simulation
** list-include-dirs : Returns a list of the modules' and it's submodules' directories containing include files. Used in top level Makefile to create project files for synthesis and simulation

== Configuration ==
Kbuild has been proposed here. Pros/cons?

I would like to have a standardized set of makefiles for every ORPSoC build, and include a Makefile.inc that contains all user parameters. I've been discussing with Saar Drimer at [https://www.boldport.com/docs/fpgaproj boldport] about integrating his work with our efforts [[User:Olof|Olof]] 09:48, 19 August 2011 (CEST)

For hardware configuration we should aim to replace defines and defparams with parameters [[User:Olof|Olof]] 21:00, 19 August 2011 (CEST)
== Software integration ==
People might want to build software running on their ORPSoC. Is this feasible?

== Name and version ==
Actually, ORPSoCv3 makes sense, but I'd prefer to see it called just ORPSoC and have version numbers (my flavor of the month) for the project when we tag it beginning at 3.0.0. We could then refer to the previous versions as 1 (the original, long gone) and 2 (the one being worked on at the moment, expect to see this in use until 3.0 gets up.)  [[User:Julius|Julius]] 14:17, 20 August 2011 (CEST)
: I agree. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Hardware ==
All critical features requests and bugs in ORPSoCv2 should be addressed before adding features (and more bugs) in ORPSoCv3.
* Fair enough. [http://bugzilla.opencores.org/show_bug.cgi?id=59 These] [http://bugzilla.opencores.org/show_bug.cgi?id=56 two] was what I could find in Bugzilla. We might need to scrape the old and new bug system to see if there are more [[User:Olof|Olof]] 23:24, 22 August 2011 (CEST)
:: I scraped the old bug tracker and put anything even vaguely still alive in Bugzilla. [[User:Jeremybennett|Jeremybennett]] 10:55, 23 August 2011 (CEST)

== Use an IP-Xact enabled tool flow ==

Orpsocv3 would be a great opportunity for opencores to stop playing catch up
and start showing a leadership roll in ip packaging and reuse by building a
complete soc design using an Ip-Xact enabled tool flow.

Ip-xact (IEEE 1685) was released in 2009 and has the potential to solve many of
our design for reuse problems but its adoption by the industry has been slow.
A big part of the problem is that a standard should simply document what everyone
is already doing but in the case of design for reuse there really aren't a lot
of examples of good working design for reuse methods. Accellera is currently working
on a update to the standard that would add in some of the vendor extensions that
tool providers have needed to make the standard workable. This is a time when we could
use orpsocv3 as a demo project for ip-xact and feedback any problems or issues back to
the ip-xact working group. I follow that groups monthly teleconferences.


Ip-xact defines an electronic data sheet in the form of an xml file that describes a
piece of ip. Every file contains an identifier known as a VLNV. That consists of the
vendor name (in our case it opencores.org) , library name. component name and version.
  
The file also lists all parameters with default values, All ports with sizes and directions
and all design "views". A view is a improvement over the traditional way that we have done
designs. We currently do "superset" designs where we create one delivierable that is sent
to all tool flows. Anything that any tool needs is added to the design and if this causes
problems for other tools (IE: Non synthesizable code) then we use translate off pragmas
or `ifndef SYNTHESIS to hide it from the other tools.

With ip-xact you create a view for each of your tool flows and each view builds its own 
deliverable with exactly what it needs and nothing more. The ip-xact file will define
a views for sim and syn and each will have their own output file.


To get started we need to understand the difference between a library and a component. 
A component is building block that we will configure and add into our design. Every component
must have an ip-xact file, Rtl code , Documentation and a test suite.

A library is a box that holds components. Usually there is a common theme that all the components
share. Or1200, minsoc and orpsocv2 are all components. openrisc is a library because it contains
several components.

opencores.org is currently using a flat database full of components mixed in with libraries.
We should add some more libraries to help us better manage all the ip. For example we should
create a library named wishbone that would either contain wishbone components or svn remote
mount them. That will give us the library name for the ip-xact files.

Also you should never create a wishbone component. If you want an i2c_controller on a wishbone
bus then you first create and i2c_controller in a logic library and then create a wishbone 
component that uses ip-xact to instantiate that i2c_controller. That way any bus de jour could
easily reuse the same i2c logic.

Currently I am building an ip-xact toolset in the socgen project that could be used to build 
all of the rtl code for a soc such as opsocv3. I recently added the ability to support busDefinitions
(really powerfull stuff) and soon will begin to add support for memory maps. With memory maps each 
ip-xact file contains a register map with all the bitfields. If you add two wishbone i2c_controllers
into oprsocv3 and rerun the build_hw script then they will appear in the .h file.

I would be happy to create and maintain all of the ip-xact files needed to build orpsocv3 and set up
the design so that you could build the rtl using the socgen toolset.

John Eaton
