= About =

OpenOCD is a program that we can use to talk to our debug interface on our hardware via JTAG, over a variety of cables, in a realtively flexible manner. We can script up things in TCL to control the system, or we can run a GDB RSP server and do things from GDB.

This page contains information about the OpenRISC 1000 architecture port.

== Features ==

The following for designs using the[http://opencores.org/project,dbg_interface SoC Debug (Mohor) Interface]:
* Memory access for program download, data inspection
* CPU register read and write
* CPU stall control
* CPU single stepping
* CPU software breakpoints
* All of the above via GDB

Support for other debug interface hardware can be added relatively easily.

= Downloading =

The OpenOCD code with basic OpenRISC 1000 support is found on the openrisc.net git tree.

 git clone git://openrisc.net/julius/openocd

= Prerequisites =

For the basic requirements of compiling and running OpenOCD see its [http://openocd.berlios.de/doc/html/index.html User Guide].

The required hardware is an [http://openocd.berlios.de/doc/html/Debug-Adapter-Hardware.html OpenOCD-supported debug cable] and an OpenRISC-based design with the supported debug interface.

So far development has been done using the [http://opencores.org/shop,item,3 ORSoC USB debug cable] against an [[ORPSoC]] system using the [http://opencores.org/project,dbg_interface SoC Debug (Mohor) Interface], but there's no reason why any other [http://openocd.berlios.de/doc/html/Debug-Adapter-Hardware.html OpenOCD-supported cable] wouldn't work.

= Building =

The source from the git repository needs to be setup before it can be configured. Instructions on this are in the README file in the root of the project. The bootstrap script for the source is run like so:

 cd openocd
 ./bootstrap

It may prompt you to install a few tools such as libtool and autoconf. Install these if they are not on your system.

Make a build directory parallel to the source and configure using the free and open source libftdi driver.
 
 mkdir bld-openocd && cd bld-openocd
 ../openocd/configure --enable-ft2232_libftdi --enable-maintainer-mode
 make

= Running =

== Setup ==

OpenOCD uses TCL for everything. The following TCL source was used during development to bring the system up. Place it in a file in the build directory (bld-openocd - presumably where you are running the following commands from.) Assume it's called or1k-dev.tcl for now:

 source [find ../openocd/tcl/target/or1k.cfg]
 
 proc or1k_test_init {} {
     
     
 }
 
 gdb_port 50001
 
 init
 #echo "Halting processor"
 halt
 
 foreach name [target names] {
     set y [$name cget -endian]
     set z [$name cget -type]
     puts [format "Chip is %s, Endian: %s, type: %s" \
                   $name $y $z]
 }

This tells OpenOCD to use the OpenRISC 1000 target configuration information which should be included with the project's source.

== Connecting to the board ==

Using something like the following to a) tell OpenOCD which cable to use to connect, and b) which TCL command file to then run some commands from. From the build directory run:

 sudo ./src/openocd -f ../openocd/tcl/interface/orsoc-jtag.cfg -f or1k-dev.tcl 

OpenOCD should establish communication with the target and stall it and wait for GDB to connect.

Add the switch ''--debug 3'' to the command line to see lots of debug output.

Note - I had to run with ''sudo'' but that's because my permissions weren't set correctly on the USB debug cable. This is not a good thing to do, and it's advisable that correct permissions on the USB debug cable are set to allow users to access it.


= Issues = 

* Not thoroughly tested - the basics have been checked on one implementation, but further use on other hardware, and feedback about it would be good.

* Lack of usage documentation. OpenOCD is quite powerful and at the moment we're using it solely as a GDB proxy.

* Resetting the target is not done properly yet in the port.

* The port, in its current state, will not be accepted in OpenOCD upstream due to the implementation of support for the read and write SPR commands done via the RSP <tt>qRcmd</tt> mechanism. Perhaps the OR1K GDB port could be changed to instead use the <tt>p</tt>/<tt>P</tt> command to access registers.
