This page contains information relating to the OpenRISC 1000 architecture and the specification document.

= OpenRISC 1000 architecture 1.0 =

This is the first update to OR1K architecture for many years. It addresses architectural and documentation issues in the manual. A summary of the main features follows:

* jump/branch delay slot is now optional
* improved version tracking
* relocatable exception vector space
* correction of arithmetic overflow and carry detection
* improvements to MAC and integer multiply behaviour
* various clarifications regarding hardware and software behaviour

See table 1-2 in the manual for a full list.

== Download OR1K 1.0 Specification ==

Architecture specification document: [http://opencores.org/websvn,filedetails?repname=openrisc&path=%2Fopenrisc%2Ftrunk%2Fdocs%2Fopenrisc-arch-1.0-rev0.pdf PDF]

== Old specifications ==

These documents are archived. For now it's just the "original" spec, it can be downloaded below:

Old Architecture manual (April 2006): [http://opencores.org/websvn,filedetails?repname=openrisc&path=%2Fopenrisc%2Ftrunk%2Fdocs%2Farchive%2Fopenrisc_arch.pdf PDF]

= Proposed changes =

This section is to keep track of proposed alterations to the OpenRISC 1000.

Feel free to add ideas and comment (please sign your name.) It also helps to post to the [[OR1K:Community_Portal#Mailing_lists|mailing list]] outlining your proposal.

The spec update process will occur from time to time and all proposals largely agreed to by the community will make it in.

=== Typos, Clarifications ===

The following section should be used to list proposed typos and clarifications which need to be made to future revisions of the architecture spec document.

==== Cache Registers Marked as Optional ====

From [http://bugzilla.opencores.org/show_bug.cgi?id=79 bug #79].

Changes to the spec document to make it clearer which cache control registers are optional.

Mark the following registers as optional to implement, as they have a "present" bit in the I/DCCFGR:

* Data Cache Control Register
* Instruction Cache Control Register
* Data Cache Block Write-Back Register

Instruction and data block invalidate and data block flush registers are mandatory, and their presence bits in the I/DCCFGR should be marked as always '1'.

==== l.lw assembly mnemonic ====

Add the l.lw assembly mnemonic, which encodes as a l.lwz instruction.

The l.lwz definition page in the spec should have:

 Format:
 l.lwz rD,I(rA)
 
 or
 
 l.lw rD,I(rA)

''Commentary:'' The downside of this is that it is potentially confusing in a 64-bit implementation, where you want to be explicit about sign extension. If we do go down this route, then for consistency, we should also have l.lh and l.lb as synonyms for l.lhz and l.lbz. [[User:Jeremybennett|Jeremybennett]] 11:32, 16 May 2012 (CEST)

rdiez: For the 32-bit architecture, in order to reduce confusion it would be best to remove the l.lws opcode, and remove the l.lws and l.lwz mnemonics, then add an "l.lw" mnemonic which maps to the old l.lwz opcode. or1200 hasn't implemented (or didn't implement) the l.lws opcode for a long time anyway. By the way, l.extws and l.extwz should also be marked as obsolete, as l.ori can achieve the same results. For the 64-bit architecture, l.lw shouldn't be a valid mnemonic, so the programmer must think whether he wants the l.lwz or the l.lws behaviour.

==== Accessing SPRs with insufficient privileges ====

At present there is no comment on what should happen in the event that l.mtspr/l.mfspr are used on SPRs which require supervisor mode to access.

I propose the specification states that a l.mtspr (write to an SPR) requiring write in supervisor mode while in user mode makes that instruction equivalent to an l.nop. Also that l.mfspr (read from an SPR) with insufficient privileges returns 0, just like an unimplemented SPR would.

firefalcon:  I propose that we keep in line with other ISAs and make the ISA fully virtualizable by throwing an exception in this case.

=== Instruction Classes ===

At present, there are class I and II instructions. Class I must always be implemented. Class II may be optionally implemented.

There are a few problems with the current scheme.

# There is no register where class II instructions are indicated as present or not
# Some fundamental instructions, such as compare-and-set-flag-against-immediate (<code>l.sf*i</code>) are class II and should really be I
# Software multi-lib support with such a configurable instruction set is difficult

Reorganising these will make it clearer which functionality should be tested and expected to be present in an implementation. It will also make it easier for software libraries to be prepared for a particular combination of supported instructions.

==== Current ORBIS32 Class II instructions ====

As of revision 0 of the specification, the following are marked as ORBIS32 class II:

* l.cmov
* l.csync
* l.cust1-8
* l.div*
* l.ext[bhw]*
* l.ff1
* l.fl1
* l.mac*,l.msb
* l.mul*
* l.psync
* l.ror,l.rori
* l.sf*i (l.sfeqi,l.sfgesi etc.)
* l.trap

==== Proposed ORBIS Classifications ====

Class I should remain mandatory to implement.

A new classification is proposed:

* Class II - Optional Maths: l.div*, l.mul* (in OR1200 on Virtex 5, serial l.div, full mult costs 265FF, 550LUT - respectively 71FF, 173LUT and 194FF, 377 LUT)
* Class III - Optional Bit Manipulation: l.ext[bwh]*, l.ff1, l.fl1, l.ror, l.rori (in OR1200 on Virtex 5 they cost 183 LUT)
* Class IV - MAC Instructions - l.mac*, l.msb
* Class V - Remaining Optional Instructions: l.cmov, l.csync, l.msync, l.psync, l.cust1-8

Classes II-IV will be all-or-nothing support classes, with class V individually implementable.

l.sf*i and l.trap should be made class I.

==== Presence bits ====

Presence bits in a new register should be added for classes II-IV, with a bit for each instruction in class V.

The CPUCFGR should be extended beyond bit 9 to contain:
 
 [25] l.cust1 instruction supported
 [24] l.cust2 instruction supported
 [23] l.cust3 instruction supported
 [22] l.cust4 instruction supported
 [21] l.cust5 instruction supported
 [20] l.cust6 instruction supported
 [19] l.cust7 instruction supported
 [18] l.cust8 instruction supported
 [17] l.cmov instruction supported
 [16] l.csync instruction supported
 [15] l.msync instruction supported
 [14] l.psync instruction supported
 [13] Class IV instruction supported
 [12] Class IV instruction supported
 [11] Class III instruction supported
 [10] Class II instruction supported

=== Atomic operations ===
One of the bigger deficiencies of the OpenRISC 1000 ISA is the lack of support for atomic operations.
This should be addressed, but a discussion whether it should be implemented as a load/link-store conditional or a atomic-rmw is needed.
This functionality should of course be optional to implement.

= Previous proposals =

The suggestions which were accepted, in one form or another, into the 1.0 release of the architecture specification can be found here: [[Architecture_Specification_1.0_proposals]].
