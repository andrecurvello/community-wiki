This page contains information relating to the OpenRISC 1000 architecture and the specification document.

= Download Latest Draft =

The latest draft of the architecture specification can be downloaded [http://opencores.org/websvn,filedetails?repname=openrisc&path=%2Fopenrisc%2Ftrunk%2Fdocs%2Fopenrisc_arch_draft.odt here] ([http://en.wikipedia.org/wiki/OpenDocument ODT format])

= Proposed changes =

This section is to keep track of proposed alterations to the OpenRISC 1000.

=== Typos, Clarifications ===

The following section should be used to list proposed typos and clarifications which need to be made to future revisions of the architecture spec document.

==== Cache Registers Marked as Optional ====

From [http://bugzilla.opencores.org/show_bug.cgi?id=79 bug #79].

Changes to the spec document to make it clearer which cache control registers are optional.

Mark the following registers as optional to implement, as they have a "present" bit in the I/DCCFGR:

* Data Cache Control Register
* Instruction Cache Control Register
* Data Cache Block Write-Back Register

Instruction and data block invalidate and data block flush registers are mandatory, and their presence bits in the I/DCCFGR should be marked as always '1'.

==== GPR0 usage, implementation ====

To eliminate confusion regarding the behaviour of writes to R0 when it's hardwired in implementation, the mention of its role according to the ABI and the potential implementation shortcuts should be removed. This is intended to imply that R0 must be implemented in the same way as the other general-purpose registers. The mention of its use as constant zero should only be present in the ABI section of the document.

The following paragraph in 4.4 should be removed:

 R0 is used as a constant zero. Whether or not R0 is actually hardwired to zero is
 implementation dependent. R0 should never be used as a destination register.
 Functions of other registers are explained in chapter Application Binary Interface on page
 319.

The following sentence should replace it:
 
 Functions of the registers are explained in chapter Application Binary Interface on page
 319.

In section 16.2.1, the following:

 R0 [Zero] Always fixed to zero. 
 Even if it is writable in some embedded implementations, the software shouldnâ€™t modify it.

Should be changed to:

 R0 [Zero] Holds a zero value.

==== l.trap condition ====

The architecture spec currently indicates the trap instruction checks a bit in the SR to test whether it should occur:

 Format:
 l.trap K
 
 Description:
 Execution of trap instruction results in the trap exception if specified bit in SR is set. Trap
 exception is a request to the operating system or to the debug facility to execute certain
 debug services. Immediate value is used to select which SR bit is tested by trap
 instruction.
 
 32-bit Implementation:
 if SR[K] = 1 then trap-exception()

This is not obeyed in any implementation and has no good justification for being specified this way. The specification should remove mention of being conditional on SR[K].

==== l.lw assembly mnemonic ====

Add the l.lw assembly mnemonic, which encodes as a l.lwz instruction.

The l.lwz definition page in the spec should have:

 Format:
 l.lwz rD,I(rA)
 
 or
 
 l.lw rD,I(rA)

''Commentary:'' The downside of this is that it is potentially confusing in a 64-bit implementation, where you want to be explicit about sign extension. If we do go down this route, then for consistency, we should also have l.lh and l.lb as synonyms for l.lhz and l.lbz. [[User:Jeremybennett|Jeremybennett]] 11:32, 16 May 2012 (CEST)

rdiez: For the 32-bit architecture, in order to reduce confusion it would be best to remove the l.lws opcode, and remove the l.lws and l.lwz mnemonics, then add an "l.lw" mnemonic which maps to the old l.lwz opcode. or1200 hasn't implemented (or didn't implement) the l.lws opcode for a long time anyway. By the way, l.extws and l.extwz should also be marked as obsolete, as l.ori can achieve the same results. For the 64-bit architecture, l.lw shouldn't be a valid mnemonic, so the programmer must think whether he wants the l.lwz or the l.lws behaviour.

==== Unused SPR space read as zero ====

It should be stated in section 4.3 that un-implemented or reserved SPR space should be read as zero and writing should have no consequence.

rdiez: In my OR10 CPU accessing non-existing SPRs raises an exception. This helps catch bugs early.

==== ABI, returning structures by value ====
Currently, the description for returning structures by value says:
 A function that returns a structure or union places the address of the structure or 
 union in the general-purpose RV register."

This should be extended with the following information:
 A function that returns a structure by value expects the location where that
 structure is to be placed to be supplied in function parameter word 0 (R3).

==== Typo for lf.sfle.d instruction ====
The current lf.sfle.d (double precision set flag less or equal) states that register rA is 364 bits in size (rA[363:0]) instead of just 64 (rA[63:0]).

=== Versioning ===

There are a few version-tracking issues to be dealt with.

==== Version Registers ====

The existing implementation version registers are not as good as they could be, and some proposals for changing them have been made.

* Add new 32-bit version register, VR2, in SPR space, address 21. It identifies the implementation (model) and version of the OpenRISC 1000 processor.

 [31:24] VER Version
 Implementation-specific version information. This value should 
 increase for more recent versions. The CPU implementation 
 specification document should indicate how to interpret this field.
 
 [23:0] CPUID CPU Identification
 Implementation-specific identification number. Each unique 
 implementation should have a unique identification value.

The 8-bit CPUID field of the VR can be used to determine the implementation. A list of know implementations and unique IDs can probably be maintained in a document kept alongside the architecture spec and/or on this wiki page. I think the OR1200 should have its ID as 0x12 and  or1ksim as 0x01. Any sufficiently different branch of any implementation, that is not likely to be re-merged, should get its own unique ID.

* A VR2-presence bit in existing VR register - bit 15 (currently reserved)

* Implementation revision/build information registers, REVIR0-REVIR4, SPR addresses 22-26. These 5 registers provide detailed information on the CPU's revision. The exact use of these registers is implementation-specific but are big enough to store a 160-bit SHA1 hash value.

The REVI registers helps us use that neat trick with git, but is mostly designed to help keep track of local modifications to the project before synthesis is performed. If people aren't using git locally there's many other ways to store local modifications there. For or1ksim, it's a way of getting a useful size amount of information into registers which the software can read.

==== Architecture Versions ====

As the architecture is modified and possibly expanded there needs to be a way of tracking the various versions of the architecture, both in implementation (eg. via a register) and in the document itself.

Although optional individual features will all have newly added presence bits to test, adherence to other architectural advances will need to be conveyed via a register for quick and easy determination by software.

For example, the GPR0 issue - there can be assurance that any implementation with an architecture revision value above 0 will adhere to the clarified definition of its implementation and use.

===== Architecture Revision Register =====

A new register, the Architecture Revision Register (ARR) should be added at address 27.

This register will contain the latest architecture revision the implementation contains features from. This will allow software to broadly detect which generation of CPU it is running on, and so which assumptions are safe.

==== Architecture Document Versions ====

The document itself will change over time as its contents are amended, clarified or expanded. There needs to be a clear way of tracking the versions of the document.

As the document is amended at present, the document revision history table in section 1.3 must be updated. However the only way to track the document revision is by the recorded date of the edit. It is proposed a new column is added to table 1-2 with an entry for each document revision of the format X-Y where X is the architecture revision the document is at that point and Y is an integer beginning at 0 for each new revision and incrementing by 1 per document update. This would mean the existing document revision is '0-17' (17 recorded updates since March 2000.) The update corresponding with the addition of new features for architecture revision 1 would mean the document revision changes to '1-0'.

=== Exception Vector Base Address ===

The current options for locations of the exception vectors are not very flexible, the only two possible locations are at
address 0x0 or address 0xf0000000.

The proposal is for the addition of an (optional) SPR register (EVBA)in group 0 (System Control and Status registers) at address 1536 (right after the last possible GPR mapped into SPR space), which would hold the (upper part of the) base address of the exception vectors.

 [31:13] Exception Vector Base Address
 Location for the start of exception vectors.
 Reset value: Implementation specific
 [12:0] Reserved / Constant 0

This register is optional, and in case EPH is asserted, it should be OR'ed together
with the value in EVBA.

The presence of EVBA can be detected in software by writing a value to it and
see if the same value reads back.

EVBA is only writable/readable when in supervisor mode (i.e. when SR[SM]=1)

=== Instruction Classes ===

At present, there are class I and II instructions. Class I must always be implemented. Class II may be optionally implemented.

There are a few problems with the current scheme.

# There is no register where class II instructions are indicated as present or not
# Some fundamental instructions, such as compare-and-set-flag-against-immediate (<code>l.sf*i</code>) are class II and should really be I
# Software multi-lib support with such a configurable instruction set is difficult

Reorganising these will make it clearer which functionality should be tested and expected to be present in an implementation. It will also make it easier for software libraries to be prepared for a particular combination of supported instructions.

==== Current ORBIS32 Class II instructions ====

As of revision 0 of the specification, the following are marked as ORBIS32 class II:

* l.cmov
* l.csync
* l.cust1-8
* l.div*
* l.ext[bhw]*
* l.ff1
* l.fl1
* l.mac*,l.msb
* l.mul*
* l.psync
* l.ror,l.rori
* l.sf*i (l.sfeqi,l.sfgesi etc.)
* l.trap

==== Proposed ORBIS Classifications ====

Class I should remain mandatory to implement.

A new classification is proposed:

* Class II - Optional Maths: l.div*, l.mul* (in OR1200 on Virtex 5, serial l.div, full mult costs 265FF, 550LUT - respectively 71FF, 173LUT and 194FF, 377 LUT)
* Class III - Optional Bit Manipulation: l.ext[bwh]*, l.ff1, l.fl1, l.ror, l.rori (in OR1200 on Virtex 5 they cost 183 LUT)
* Class IV - MAC Instructions - l.mac*, l.msb
* Class V - Remaining Optional Instructions: l.cmov, l.csync, l.msync, l.psync, l.cust1-8

Classes II-IV will be all-or-nothing support classes, with class V individually implementable.

l.sf*i and l.trap should be made class I.

==== Presence bits ====

Presence bits in a new register should be added for classes II-IV, with a bit for each instruction in class V.

The CPUCFGR should be extended beyond bit 9 to contain:
 
 [25] l.cust1 instruction supported
 [24] l.cust2 instruction supported
 [23] l.cust3 instruction supported
 [22] l.cust4 instruction supported
 [21] l.cust5 instruction supported
 [20] l.cust6 instruction supported
 [19] l.cust7 instruction supported
 [18] l.cust8 instruction supported
 [17] l.cmov instruction supported
 [16] l.csync instruction supported
 [15] l.msync instruction supported
 [14] l.psync instruction supported
 [13] Class IV instruction supported
 [12] Class IV instruction supported
 [11] Class III instruction supported
 [10] Class II instruction supported

=== Delay Slot Optional ===

There is a proposal to make delay slots optional. This will be stated in the architecture specification. Whether a machine has branch delay slots will be indicated via a the <tt>ND</tt> bit (position 10) in <tt>CPUCFGR</tt>.

On machines where <tt>CPUCFGR[ND]</tt> is set, jumps and branches change the PC immediately, instead of after the following delay slot instruction.
Additionally, the <tt>l.jal</tt> and <tt>l.jalr</tt> instructions write <tt>PC+4</tt> to the link register (<tt>R9</tt>), instead of <tt>PC+8</tt>.

The following changes will be made to the toolchain in order to facilitate the use of this option:

* The <tt>EF_OR1K_NODELAY</tt> bit (position 0) in the flags field of the ELF header will be set in all binaries.  The linker should warn whenever this bit is incompatibly set, but not fail or abort.  This warning should be able to be turned off.

* GAS will now understand the directive <tt>.nodelay</tt>.  For now its only effect is to cause the EF_OR1K_NODELAY bit in the ELF file to be set.

* GCC will have the following new flags:

** <tt>-mdelay</tt>: forces use of the delay slot
** <tt>-mno-delay</tt>: forces branches and jumps to not have a delay slot
** <tt>-mcompat-delay</tt>: forces delay slots, and fills them with nops

* The <tt>or1knd-elf</tt> and <tt>or1knd-linux</tt> machine specifications will be added.

** When GCC is compiled for the <tt>or1k-*</tt> targets, <tt>-mdelay</tt> will be the default
** When GCC is compiled for the <tt>or1knd-*</tt> targets, <tt>-mno-delay</tt> will be the default
** GCC compiled for either target will understand all 3 flags
** When using <tt>-mno-delay</tt> GCC will emit a <tt>.nodelay</tt> directive in the intermediate <tt>.s</tt> file, and the C preprocessor will include the predefined macro <tt>__OR1K_NODELAY__</tt>
** Separate GCC multilib configurations might be useful for each of these flags

* <tt>or1ksim</tt> will be modified to allow the delay slot to be disabled.  This can be configured by setting the ND bit (position 10) in the <tt>cfg</tt> configuration variable of the <tt>cpu</tt> section of <tt>sim.cfg</tt>.

* Where necessary, assembly source files (in testsuites, newlib, etc.) will be modified to use the C preprocessor to detect whether delay slots are to be used, and possibly exchange the position of delay slot instructions.

=== Change Use of Carry and Overflow Flags by Multiply Instructions ===

This proposal aims to simplify the implementation of the OpenRISC multiplier, as well as resolve conflicting implementation between the OR1200 and or1ksim.

The <tt>l.mul</tt> instruction is hard to implement in the current state.  It performs a signed multiply, but must the set CY flag to indicate that overflow would have happened if the numbers were treated as unsigned.  This is difficult to implement because multiplier macros and DSP slices on FPGAs only let you do either signed or unsigned multiply, and almost never give you the ability to detect unsigned overflow when doing signed multiply.  Implementing it pretty much requires a hand-coded multiplier.  The or1ksim simulator does get this requirement correct, but it does so by multiplying the operands twice, in both signed and unsigned modes.  Notably, the OR1200 does not appear to implement this correctly.  Instead, it appears to set the OV bit for both signed overflow in <tt>l.mul</tt> and unsigned overflow in <tt>l.mulu</tt>.

For consistency, we will always use OV to indicate signed overflow, and CY to indicate unsigned overflow.  We will add a CYE bit to the SR register that causes a RANGE exception to be triggered when the CY bit is set by an instruction.  Additionally, we will change the requirement that the <tt>l.mul</tt> instruction set the CY bit for unsigned overflow, and instead require that it always clear the bit.  (I had considered having it just leave that bit unchanged, but it seems all the arithmetic instructions write both, if only to clear them, so just clearing it is more consistent.)

Summary of changes:

* Remove the requirement that the <tt>l.mul</tt> instruction set the CY flag to indicate unsigned overflow.  The instruction will no longer modify the CY flag at all.

* Remove the requirement that the <tt>l.mulu</tt> instruction clear the OV flag.  The instruction will no longer modify the OV flag at all.

* Add a CYE bit to the SR register that, when set, causes the processor to trigger a RANGE exception when an instruction sets the CY bit.

=== Multiply and Accumulate ===

This is a potentially disruptive change, as it is different from the operation of the OR1200.  It may be a good idea to implement it under a new UPR code or similar.

The <tt>l.mac</tt> instructions truncate the product of the two registers to 32-bits before performing a 64-bit add.  This seems less useful, and unnecessary, since the simplest implementation of the <tt>l.mul</tt> instructions would use a 32x32-bit to 64-bit multiplier in order to be implemented using FPGA DSP slices, and still accurately capture the signed/unsigned overflow flags. Additionally, the MACHI register value is only useful if the programmer knows the product of the operands fits in 32 bits.

So I propose changing the <tt>l.mac</tt> instruction to perform a full 64-bit addition of the accumulator and the 64-bit product, without first truncating the product to 32 bits.

Note that if the programmer has already guaranteed that the products are smaller than 32 bits, the program will produce the same result after this ISA change.  Additionally, the the MACLO value produced will be identical to before, so if the program only uses <tt>l.mac</tt>, <tt>l.msb</tt>, and <tt>l.macrc</tt> instructions, there will be no visible difference.

Additionally, it seems simple and useful to add unsigned versions of the mac instructions, and a version that does not perform an add or subtraction, and allows the full 64-bit product to be recovered from the HI/LO registers.

Finally, these changes will simplify the implementation and improve the performance of C <tt>long long</tt> and bignums in general.

Summary of changes:

* Change <tt>l.mac</tt> and <tt>l.msb</tt> to perform a full 32x32 to 64-bit product, and add the full 64-bit product to the 64-bit accumulator without any truncation.

* Add <tt>l.macu</tt> and <tt>l.msbu</tt>, which are like <tt>l.mac</tt> and <tt>l.msb</tt>, but perform an unsigned multiplication

* Add <tt>l.muld</tt> and <tt>l.muldu</tt>, which perform a signed/unsigned 32x32 to 64-bit product and write the result to MACHI/MACLO.

=== Atomic operations ===
One of the bigger deficiencies of the OpenRISC 1000 ISA is the lack of support for atomic operations.
This should be addressed, but a discussion whether it should be implemented as a load/link-store conditional or a atomic-rmw is needed.
This functionality should of course be optional to implement.
