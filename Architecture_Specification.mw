This page contains information relating to the OpenRISC 1000 architecture and the specification document.

= Download Latest Draft =

The latest draft of the architecture specification can be downloaded [http://opencores.org/websvn,filedetails?repname=openrisc&path=%2Fopenrisc%2Ftrunk%2Fdocs%2Fopenrisc_arch_draft.odt here] ([http://en.wikipedia.org/wiki/OpenDocument ODT format])

= Proposed changes =

This section is to keep track of proposed alterations to the OpenRISC 1000.

=== Typos, Clarifications ===

The following section should be used to list proposed typos and clarifications which need to be made to future revisions of the architecture spec document.

==== Cache Registers Marked as Optional ====

From [http://bugzilla.opencores.org/show_bug.cgi?id=79 bug #79].

Changes to the spec document to make it clearer which cache control registers are optional.

Mark the following registers as optional to implement, as they have a "present" bit in the I/DCCFGR:

* Data Cache Control Register
* Instruction Cache Control Register
* Data Cache Block Flush Register
* Data Cache Block Invalidate Register
* Data Cache Block Write-Back Register
* Instruction Cache Block Invalidate Register

==== Cache Block Invalidate Behaviour Clarification ====

There are two issues with the cache block invalidation description.

# The behaviour when the address written to the instruction or data cache block invalidate register (xBIR) is not actually cached is not clear - should the corresponding block be marked invalid/empty or not? Current practice in implementations is to not regarding the address and clear the block regardless.
# There appears to be no way of clearing a block in a particular way.

The proposed clarifications are:
# Add to the block invalidate register's function description that the address beyond the bits used to select the cache block are ignored when invalidating, and the invalidation will always occur regardless of whether the block is currently valid. This clears up the behaviour and makes it obvious that software must clear the cache tags after reset.
# State that block invalidation occurs for all ways.

==== GPR0 usage, implementation ====

It's not clear at the moment whether GPR0 really should be zero all the time and whether implementations would be free to tie it to zero.

The following paragraph in 4.4 should be removed:

 R0 is used as a constant zero. Whether or not R0 is actually hardwired to zero is
 implementation dependent. R0 should never be used as a destination register.
 Functions of other registers are explained in chapter Application Binary Interface on page
 319.

The following paragraph should replace it:
 
 R0 is used as a constant zero according to the ABI. R0 may or may not be hard-wired to zero 
 in implementation. In the case where it is hard-wired to zero, no exception will be raised 
 when it is used as a destination register. 

The following paragraph should be added to the ABI section on GPR0's usage:

 R0 is used as a constant zero. If the register is not hard-wired to zero it should be cleared 
 by software on reset.

==== l.trap condition ====

The architecture spec currently indicates the trap instruction checks a bit in the SR to test whether it should occur:

 Format:
 l.trap K
 
 Description:
 Execution of trap instruction results in the trap exception if specified bit in SR is set. Trap
 exception is a request to the operating system or to the debug facility to execute certain
 debug services. Immediate value is used to select which SR bit is tested by trap
 instruction.
 
 32-bit Implementation:
 if SR[K] = 1 then trap-exception()

This is not obeyed in any implementation and has no good justification for being specified this way. The specification should remove mention of being conditional on SR[K].

=== Versioning ===

There are a few version-tracking issues to be dealt with.

==== Version Registers ====

The existing implementation version registers are not as good as they could be, and some proposals for changing them have been made.

* Add new 32-bit version register, VR2, in SPR space, address 9. It identifies the implementation (model) and version of the OpenRISC 1000 processor.

 [31:24] VER Version
 Implementation-specific version information. This value should 
 increase for more recent versions. The CPU implementation 
 specification document should indicate how to interpret this field.
 
 [23:0] CPUID CPU Identification
 Implementation-specific identification number. Each unique 
 implementation should have a unique identification value.

The 8-bit CPUID field of the VR can be used to determine the implementation. A list of know implementations and unique IDs can probably be maintained in a document kept alongside the architecture spec and/or on this wiki page. I think the OR1200 should have its ID as 0x12 and  or1ksim as 0x01. Any sufficiently different branch of any implementation, that is not likely to be re-merged, should get its own unique ID.

* A VR2-presence bit in existing VR register - bit 15 (currently reserved)

* Implementation revision/build information registers, REVIR0-REVIR4, SPR addresses 10-14. These 5 registers provide detailed information on the CPU's revision. The exact use of these registers is implementation-specific but are big enough to store a 160-bit SHA1 hash value.

The REVI registers helps us use that neat trick with git, but is mostly designed to help keep track of local modifications to the project before synthesis is performed. If people aren't using git locally there's many other ways to store local modifications there. For or1ksim, it's a way of getting a useful size amount of information into registers which the software can read.

==== Architecture Versions ====

As the architecture is modified and possibly expanded there needs to be a way of tracking the various versions of the architecture, both in implementation (eg. via a register) and in the document itself.

==== Architecture Document Versions ====

The document itself will change over time as its contents are amended, clarified or expanded. There needs to be a clear way of tracking the versions of the document. At present, the current draft document is revision 0 pending the first set of updates to the architecture.

=== Exception Vector Base Address ===

The current options for locations of the exception vectors are not very flexible, the only two possible locations are at
address 0x0 or address 0xf0000000.

The proposal is for the addition of an (optional) SPR register (EVBA)in group 0 (System Control and Status registers) at address 1536 (right after the last possible GPR mapped into SPR space), which would hold the (upper part of the) base address of the exception vectors.

=== Instruction Classes ===

At present, there are class I and II instructions. Class I must always be implemented. Class II may be optionally implemented.

There are a few problems with the current scheme.

# There is no register where class II instructions are indicated as present or not
# Some fundamental instructions, such as compare-and-set-flag-against-immediate (<code>l.sf*i</code>) are class II and should really be I
# Software multi-lib support with such a configurable instruction set is difficult

Reorganising these will make it clearer which functionality should be tested and expected to be present in an implementation. It will also make it easier for software libraries to be prepared for a particular combination of supported instructions.

==== Current ORBIS32 Class II instructions ====

* l.cmov
* l.csync
* l.cust1-8
* l.div*
* l.ext[bhw]*
* l.ff1
* l.fl1
* l.mac*,l.msb
* l.mul*
* l.psync
* l.ror,l.rori
* l.sf*i (l.sfeqi,l.sfgesi etc.)
* l.trap

==== Proposed ORBIS Classifications ====

Class I should remain mandatory to implement.

A new classification is proposed:

* Class II - Optional Maths: l.div*, l.mul*
* Class III - Optional Bit Manipulation: l.ext[bwh]*, l.ff1, l.fl1, l.ror, l.rori
* Class IV - MAC Instructions - l.mac*, l.msb
* Class V - Remaining Optional Instructions: l.cmov, l.csync, l.msync, l.psync, l.cust1-8, l.trap

Classes II-IV will be all-or-nothing support classes, with class V individually implementable.

l.sf*i should be made class I.

Some candidates for being moved from class I to class V are:
* l.sys (very operating system-specific)

==== Presence bits ====

Presence bits in a new register should be added for classes II-IV, with a bit for each instruction in class V.
